<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Chromebook DAW Advanced</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    :root {
      --bg: #181c21;
      --panel: #232b36;
      --accent: #ff9500;
      --accent2: #ff5050;
      --clip: #1de9b6;
      --clip-selected: #00bcd4;
      --track-bg: #232b36;
      --timeline: #21272e;
      --text: #e9e9f3;
      --text2: #aaa;
      --grid: #444e5e;
      --beat: #6d8099;
      --muted: #333a42;
    }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: 'Segoe UI', Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
      min-width: 900px;
      height: 100vh;
      overflow: hidden;
    }
    header {
      background: var(--panel);
      color: var(--text);
      padding: 1rem 2rem 0.5rem 2rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      border-bottom: 2px solid var(--accent);
      box-shadow: 0 4px 12px #0004;
    }
    header h1 { margin: 0; font-size: 1.5rem; font-weight: bold; }
    #toolbar {
      display: flex;
      gap: 1rem;
      align-items: center;
    }
    button, label.upload-btn, select, input[type="number"] {
      background: var(--panel);
      color: var(--text);
      border: 1px solid var(--timeline);
      padding: 0.5em 1.2em;
      border-radius: 4px;
      font-size: 1rem;
      cursor: pointer;
      transition: background 0.2s, border 0.2s;
      margin: 0 2px;
      outline: none;
    }
    button:active, label.upload-btn:active, select:active {
      background: var(--accent2);
    }
    button.active, .metronome-on {
      background: var(--accent);
      color: #222;
      border-color: var(--accent2);
    }
    label.upload-btn {
      display: inline-block;
      position: relative;
    }
    label.upload-btn input[type="file"] { display: none; }

    #workspace {
      margin: 1.2rem 1.7rem 1.2rem 1.7rem;
      background: var(--bg);
      border-radius: 10px;
      box-shadow: 0 4px 24px #0003;
      padding: 0.7rem 1rem 1.5rem 1rem;
      min-height: 420px;
      overflow: auto;
      border: 2px solid var(--panel);
      position: relative;
      height: 80vh;
    }
    #timeline {
      position: relative;
      height: 50px;
      border-bottom: 2px solid var(--timeline);
      background: var(--timeline);
      user-select: none;
      min-width: 900px;
      z-index: 10;
      font-size: 1em;
    }
    .bar-marker {
      position: absolute;
      top: 0;
      width: 2px;
      height: 80%;
      background: var(--accent);
      opacity: 0.9;
    }
    .beat-marker {
      position: absolute;
      top: 0;
      width: 1px;
      height: 60%;
      background: var(--beat);
      opacity: 0.7;
    }
    .bar-label {
      position: absolute;
      top: 18px;
      color: var(--accent);
      font-weight: bold;
      font-size: 0.95em;
      z-index: 2;
      pointer-events: none;
      text-shadow: 0 2px 2px #000a;
    }
    .track {
      background: var(--track-bg);
      margin-bottom: 10px;
      border-radius: 6px;
      min-height: 90px;
      position: relative;
      overflow: visible;
      display: flex;
      align-items: flex-end;
      min-width: 900px;
      border-bottom: 1px solid var(--timeline);
      transition: background 0.2s;
    }
    .track.muted { background: var(--muted); opacity: 0.65;}
    .track-label {
      position: absolute;
      left: -70px;
      top: 36px;
      width: 60px;
      font-size: 1rem;
      color: var(--text2);
      text-align: right;
      font-weight: bold;
    }
    .clip {
      position: absolute;
      top: 15px;
      height: 70px;
      border-radius: 8px;
      background: var(--clip);
      box-shadow: 0 2px 10px #0003;
      border: 2px solid transparent;
      cursor: grab;
      display: flex;
      align-items: center;
      z-index: 2;
      transition: border .15s, background .15s;
      opacity: 0.97;
    }
    .clip.selected {
      border: 2px solid var(--clip-selected);
      background: var(--clip-selected);
      box-shadow: 0 2px 12px var(--clip-selected);
      opacity: 1;
    }
    .clip .waveform-canvas,
    .record-preview .waveform-canvas {
      height: 62px;
      width: 98%;
      border-radius: 7px;
      display: block;
      background: transparent;
      pointer-events: none;
      margin: 2px 2px;
    }
    .record-preview {
      position: absolute;
      top: 15px;
      height: 70px;
      border-radius: 8px;
      background: var(--accent2);
      opacity: 0.7;
      z-index: 9;
      display: flex;
      align-items: center;
      pointer-events: none;
    }
    .playhead {
      position: absolute;
      top: 0;
      width: 3px;
      height: 100%;
      background: var(--accent2);
      z-index: 20;
      pointer-events: none;
      box-shadow: 0 0 12px #f33;
    }
    .track-controls {
      display: flex;
      gap: 10px;
      margin-left: 80px;
      margin-bottom: 0.5rem;
    }
    .track-controls button {
      background: var(--accent);
      color: #222;
      font-weight: bold;
      border-radius: 4px;
      padding: 0.2em 0.7em;
      font-size: 0.9em;
      border: none;
    }
    .settings-bar {
      margin-top: 0.3rem;
      background: var(--panel);
      border-radius: 7px;
      padding: 0.5em 1.5em;
      display: flex;
      align-items: center;
      gap: 1.5em;
      font-size: 1em;
      color: var(--text2);
      box-shadow: 0 2px 6px #0002;
      margin-bottom: 0.5em;
      user-select: none;
    }
    .settings-bar label {
      margin-right: 0.3em;
      font-weight: bold;
      color: var(--accent);
    }
    .settings-bar input[type="number"] {
      width: 60px;
      background: var(--timeline);
      color: var(--text);
      border-radius: 4px;
      border: 1px solid var(--accent);
      text-align: right;
      font-size: 1em;
      padding: 0.2em 0.3em;
    }
    .settings-bar select {
      background: var(--timeline);
      color: var(--text);
      border-radius: 4px;
      border: 1px solid var(--accent2);
      font-size: 1em;
      padding: 0.2em 0.4em;
    }
    .settings-bar .metronome-btn {
      background: var(--accent2);
      border: 2px solid var(--accent);
      color: #fff;
      font-weight: bold;
      border-radius: 5px;
      font-size: 0.98em;
      padding: 0.3em 1em;
      margin-left: 0.8em;
      transition: background 0.15s;
    }
    .settings-bar .metronome-on {
      background: var(--accent);
      color: #222;
    }
    .settings-bar .zoom-btn {
      background: var(--timeline);
      border: 1px solid var(--accent2);
      color: var(--accent2);
      font-size: 1.1em;
      padding: 0.22em 0.7em;
      border-radius: 5px;
      margin: 0 0.2em;
    }
    /* Context Menu */
    .context-menu {
      position: fixed;
      background: #232b36;
      color: #eee;
      border: 1.5px solid #232b36;
      border-radius: 7px;
      box-shadow: 0 2px 16px #000b;
      z-index: 9999;
      min-width: 180px;
      padding: 0.2em 0;
      font-size: 1em;
    }
    .context-menu .context-menu-item {
      padding: 0.6em 1.2em;
      cursor: pointer;
      user-select: none;
      transition: background 0.13s;
      border-bottom: 1px solid #232b36;
    }
    .context-menu .context-menu-item:last-child {
      border-bottom: none;
    }
    .context-menu .context-menu-item:hover {
      background: #374151;
    }
    .context-menu .context-menu-sep {
      border-top: 1px solid #546;
      margin: 2px 0;
    }
    /* Color Picker */
    .color-picker {
      margin-left: 0.6em;
      vertical-align: middle;
      width: 22px;
      height: 22px;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 1px 4px #0008;
    }
    @media (max-width: 700px) {
      #workspace { margin: 0.5rem; padding: 0.5rem;}
      header { flex-direction: column; gap: 0.5em;}
      .track-label { left: -60px; width: 50px;}
      .settings-bar { flex-direction: column; gap:0.5em;}
    }
  </style>
</head>
<body>
  <header>
    <h1>Chromebook DAW Advanced</h1>
    <div id="toolbar">
      <button id="recordBtn" title="Record (R)">üéôÔ∏è</button>
      <button id="stopBtn" title="Stop (S)" disabled>‚èπÔ∏è</button>
      <button id="playBtn" title="Play (Space)">‚ñ∂Ô∏è</button>
      <button id="pauseBtn" title="Pause" disabled>‚è∏Ô∏è</button>
      <label class="upload-btn" title="Upload audio">
        ‚¨ÜÔ∏è
        <input type="file" id="fileInput" accept="audio/*" multiple>
      </label>
      <button id="addTrackBtn" title="Add a new track">‚ûï</button>
    </div>
  </header>
  <div class="settings-bar">
    <label for="bpm">Tempo:</label>
    <input type="number" id="bpm" min="20" max="300" value="120"> BPM
    <label for="timeSigNum">Time Signature:</label>
    <select id="timeSigNum">
      <option value="4">4</option>
      <option value="3">3</option>
      <option value="6">6</option>
      <option value="5">5</option>
      <option value="7">7</option>
    </select>
    /
    <select id="timeSigDen">
      <option value="4">4</option>
      <option value="8">8</option>
      <option value="16">16</option>
    </select>
    <button class="metronome-btn" id="metronomeBtn">Metronome Off</button>
    <span style="margin-left:2em;">
      <button class="zoom-btn" id="zoomInBtn" title="Zoom in">Ôºã</button>
      <button class="zoom-btn" id="zoomOutBtn" title="Zoom out">Ôºç</button>
    </span>
  </div>
  <div id="workspace">
    <div id="timeline"></div>
    <div id="tracks"></div>
  </div>
  <script>
    // --- DAW Constants ---
    const BASE_PIXELS_PER_SEC = 110;
    const MIN_CLIP_WIDTH = 36;
    const DEFAULT_TRACKS = 2;
    const DEFAULT_BPM = 120;
    const DEFAULT_SIG_NUM = 4;
    const DEFAULT_SIG_DEN = 4;
    const MAX_TIME = 180; // seconds
    const MAX_BARS = 128;
    const CLIP_COLORS = [
      "#1de9b6", "#42a5f5", "#ffb300", "#ec407a", "#ffd600", "#8bc34a",
      "#00bcd4", "#ba68c8", "#ff7043", "#90caf9", "#cddc39"
    ];
    const TRACK_COLORS = [
      "#374151", "#232b36", "#2d3748", "#3b4252", "#223",
    ];

    // --- State ---
    let tracks = [];
    let audioCtx = null;
    let isRecording = false;
    let mediaRecorder = null;
    let recordedChunks = [];
    let liveRecordingBuffer = [];
    let liveRecordingStart = 0;
    let playheadTime = 0;
    let playRequestId = null;
    let playing = false;
    let selectedClip = null;
    let copiedClip = null;
    let zoomLevel = 1;
    let PIXELS_PER_SEC = BASE_PIXELS_PER_SEC;
    let bpm = DEFAULT_BPM;
    let timeSigNum = DEFAULT_SIG_NUM;
    let timeSigDen = DEFAULT_SIG_DEN;
    let metronomeEnabled = false;
    let metronomeTimeout = null;
    let metronomeTickBuffer = null;
    let metronomeAccentBuffer = null;
    let contextMenuEl = null;

    // DOM Elements
    const recordBtn = document.getElementById('recordBtn');
    const stopBtn = document.getElementById('stopBtn');
    const playBtn = document.getElementById('playBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const timelineDiv = document.getElementById('timeline');
    const tracksDiv = document.getElementById('tracks');
    const fileInput = document.getElementById('fileInput');
    const addTrackBtn = document.getElementById('addTrackBtn');
    const bpmInput = document.getElementById('bpm');
    const tsNumInput = document.getElementById('timeSigNum');
    const tsDenInput = document.getElementById('timeSigDen');
    const metronomeBtn = document.getElementById('metronomeBtn');
    const zoomInBtn = document.getElementById('zoomInBtn');
    const zoomOutBtn = document.getElementById('zoomOutBtn');
    const workspace = document.getElementById('workspace');

    // --- Data Model ---
    function createTrack(label, color) {
      return {
        label: label || `Track ${tracks.length + 1}`,
        color: color || TRACK_COLORS[tracks.length % TRACK_COLORS.length],
        clips: [],
        muted: false,
        solo: false,
        id: Math.random().toString(36).slice(2,9)
      };
    }
    function createClip(audioBuffer, startTime, duration, offset=0, color, name) {
      return {
        id: Math.random().toString(36).slice(2,9),
        audioBuffer,
        startTime, // in seconds
        duration,  // in seconds
        offset,    // in seconds, offset in source buffer
        selected: false,
        color: color || CLIP_COLORS[Math.floor(Math.random()*CLIP_COLORS.length)],
        name: name || "Clip"
      };
    }

    // --- Timeline ---
    function getSecPerBeat() { return 60 / bpm; }
    function getSecPerBar() { return getSecPerBeat() * timeSigNum; }
    function getTotalBars() { return Math.ceil(MAX_TIME / getSecPerBar()); }
    function getTimelineWidth() {
      return Math.max(getTotalBars() * getSecPerBar() * PIXELS_PER_SEC, 900);
    }

    function renderTimeline() {
      timelineDiv.innerHTML = '';
      timelineDiv.style.width = getTimelineWidth() + 'px';
      // Draw bars and beats
      for (let bar = 0; bar <= getTotalBars(); bar++) {
        let left = bar * getSecPerBar() * PIXELS_PER_SEC;
        let marker = document.createElement('div');
        marker.className = 'bar-marker';
        marker.style.left = left + 'px';
        marker.style.height = '80%';
        timelineDiv.appendChild(marker);
        let label = document.createElement('span');
        label.className = 'bar-label';
        label.innerText = `${bar+1}`;
        label.style.left = (left+2) + 'px';
        timelineDiv.appendChild(label);
        // Beats for this bar
        if (bar < getTotalBars()) {
          for (let beat = 1; beat < timeSigNum; beat++) {
            let bleft = left + beat * getSecPerBeat() * PIXELS_PER_SEC;
            let bm = document.createElement('div');
            bm.className = 'beat-marker';
            bm.style.left = bleft + 'px';
            bm.style.height = '60%';
            timelineDiv.appendChild(bm);
          }
        }
      }
      // Playhead
      let playhead = document.createElement('div');
      playhead.className = 'playhead';
      playhead.style.left = (playheadTime * PIXELS_PER_SEC) + 'px';
      playhead.style.height = '100%';
      timelineDiv.appendChild(playhead);
    }

    // --- Tracks and Clips ---
    function renderTracks() {
      tracksDiv.innerHTML = '';
      tracks.forEach((track, tIdx) => {
        let trackDiv = document.createElement('div');
        trackDiv.className = 'track' + (track.muted ? ' muted' : '');
        trackDiv.style.height = "90px";
        trackDiv.style.position = 'relative';
        trackDiv.style.background = track.color;
        trackDiv.dataset.track = tIdx;

        let label = document.createElement('span');
        label.className = 'track-label';
        label.innerText = track.label;
        trackDiv.appendChild(label);

        // Render Clips
        track.clips.forEach((clip, cIdx) => {
          let clipDiv = document.createElement('div');
          clipDiv.className = 'clip' + (clip.selected ? ' selected' : '');
          const left = clip.startTime * PIXELS_PER_SEC;
          const width = Math.max(clip.duration * PIXELS_PER_SEC, MIN_CLIP_WIDTH);
          clipDiv.style.left = left + 'px';
          clipDiv.style.width = width + 'px';
          clipDiv.draggable = true;
          clipDiv.tabIndex = 0;
          clipDiv.dataset.track = tIdx;
          clipDiv.dataset.clip = cIdx;
          clipDiv.title = clip.name + ' - Drag to move. Right-click for actions';
          clipDiv.style.background = clip.color;

          // Waveform Canvas
          let canvas = document.createElement('canvas');
          canvas.className = 'waveform-canvas';
          canvas.width = width - 8;
          canvas.height = 62;
          drawWaveform(canvas, clip.audioBuffer, clip.offset, clip.duration, false);
          clipDiv.appendChild(canvas);

          // Name
          let nameDiv = document.createElement('div');
          nameDiv.style.position = 'absolute';
          nameDiv.style.left = '7px';
          nameDiv.style.top = '2px';
          nameDiv.style.fontWeight = 'bold';
          nameDiv.style.fontSize = '0.92em';
          nameDiv.style.color = '#21272e';
          nameDiv.innerText = clip.name;
          clipDiv.appendChild(nameDiv);

          // Dragging
          clipDiv.addEventListener('dragstart', (e) => {
            e.dataTransfer.setData('text/plain', JSON.stringify({tIdx, cIdx}));
          });

          clipDiv.addEventListener('click', (e) => {
            selectClip(tIdx, cIdx);
            e.stopPropagation();
          });

          // Right click: advanced DAW menu
          clipDiv.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            showClipContextMenu(e, tIdx, cIdx, clipDiv);
          });

          trackDiv.appendChild(clipDiv);
        });

        // Live recording preview
        if (isRecording && tIdx === 0 && liveRecordingBuffer.length > 0) {
          const recLeft = liveRecordingStart * PIXELS_PER_SEC;
          const recDuration = liveRecordingBuffer.length / (audioCtx ? audioCtx.sampleRate : 44100);
          const recWidth = Math.max(recDuration * PIXELS_PER_SEC, MIN_CLIP_WIDTH);
          let recDiv = document.createElement('div');
          recDiv.className = 'record-preview';
          recDiv.style.left = recLeft + 'px';
          recDiv.style.width = recWidth + 'px';

          let recCanvas = document.createElement('canvas');
          recCanvas.className = 'waveform-canvas';
          recCanvas.width = recWidth - 8;
          recCanvas.height = 62;
          drawWaveform(recCanvas, liveRecordingBuffer, 0, recDuration, true);
          recDiv.appendChild(recCanvas);
          trackDiv.appendChild(recDiv);
        }

        // Drag Over to Drop Clips
        trackDiv.addEventListener('dragover', (e) => e.preventDefault());
        trackDiv.addEventListener('drop', (e) => {
          e.preventDefault();
          let data = JSON.parse(e.dataTransfer.getData('text/plain'));
          let relX = e.offsetX;
          moveClip(data.tIdx, data.cIdx, tIdx, relX / PIXELS_PER_SEC);
        });

        // Track right-click context menu
        trackDiv.addEventListener('contextmenu', (e) => {
          e.preventDefault();
          showTrackContextMenu(e, tIdx, trackDiv);
        });

        tracksDiv.appendChild(trackDiv);
      });
    }

    // --- Waveform Drawing ---
    function drawWaveform(canvas, audioBufferOrBuffer, offset, duration, isRawBuffer) {
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.strokeStyle = isRawBuffer ? "rgba(255,60,60,1)" : 'rgba(50,50,70,0.99)';
      ctx.lineWidth = 2.2;
      ctx.beginPath();
      let channel;
      let sampleRate = 44100;
      if (isRawBuffer && Array.isArray(audioBufferOrBuffer)) {
        channel = audioBufferOrBuffer;
        sampleRate = audioCtx ? audioCtx.sampleRate : 44100;
      } else if (audioBufferOrBuffer && audioBufferOrBuffer.getChannelData) {
        channel = audioBufferOrBuffer.getChannelData(0);
        sampleRate = audioBufferOrBuffer.sampleRate;
      } else {
        return;
      }
      const start = Math.floor(offset * sampleRate);
      const end = Math.min(channel.length, Math.floor((offset+duration) * sampleRate));
      const samples = end - start;
      const step = Math.max(1, Math.floor(samples / canvas.width));
      for (let x = 0; x < canvas.width; x++) {
        const idx = start + Math.floor(x * samples / canvas.width);
        let min = 1.0, max = -1.0;
        for (let j = 0; j < step && idx + j < end; j++) {
          const val = channel[idx + j];
          min = Math.min(min, val);
          max = Math.max(max, val);
        }
        const y1 = (1 - (max+1)/2) * canvas.height;
        const y2 = (1 - (min+1)/2) * canvas.height;
        ctx.moveTo(x, y1);
        ctx.lineTo(x, y2);
      }
      ctx.stroke();
    }

    // --- Rendering ---
    function render() {
      renderTimeline();
      renderTracks();
    }

    // --- Recording ---
    recordBtn.onclick = async () => {
      if (isRecording) return;
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      let stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
      recordedChunks = [];
      liveRecordingBuffer = [];
      liveRecordingStart = playheadTime;
      let inputNode = audioCtx.createMediaStreamSource(stream);

      // Live preview using ScriptProcessorNode for waveform
      let processor = audioCtx.createScriptProcessor(4096, 1, 1);
      inputNode.connect(processor);
      processor.connect(audioCtx.destination);
      processor.onaudioprocess = (e) => {
        let input = e.inputBuffer.getChannelData(0);
        liveRecordingBuffer.push(...input);
        if (liveRecordingBuffer.length > audioCtx.sampleRate * 300) {
          processor.disconnect();
          inputNode.disconnect();
        }
        render();
      };

      mediaRecorder.ondataavailable = e => { recordedChunks.push(e.data); };
      mediaRecorder.onstop = async () => {
        processor.disconnect();
        inputNode.disconnect();
        if (recordedChunks.length === 0) { isRecording = false; recordBtn.disabled = false; stopBtn.disabled = true; return; }
        const blob = new Blob(recordedChunks, { type: 'audio/webm' });
        const arrayBuffer = await blob.arrayBuffer();
        audioCtx.decodeAudioData(arrayBuffer, (buffer) => {
          addClipToFirstTrack(buffer, liveRecordingStart, buffer.duration);
          liveRecordingBuffer = [];
          render();
        });
        isRecording = false;
        recordBtn.disabled = false;
        stopBtn.disabled = true;
      };

      mediaRecorder.start();
      isRecording = true;
      recordBtn.disabled = true;
      stopBtn.disabled = false;
      if (metronomeEnabled) startMetronome();
    };

    stopBtn.onclick = () => {
      if (isRecording) {
        mediaRecorder.stop();
        if (metronomeEnabled) stopMetronome();
      }
      stopAll();
    };

    // --- Playback: Stable, true-rate, accurate ---
    playBtn.onclick = () => { playAll(); };
    pauseBtn.onclick = () => { stopAll(); };

    function playAll() {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      stopAll();
      let playStartAudioCtx = audioCtx.currentTime;
      let playStartTime = playheadTime;
      playing = true;
      function step() {
        let elapsed = audioCtx.currentTime - playStartAudioCtx;
        let t = playStartTime + elapsed;
        updatePlayhead(t);
        if (t > MAX_TIME) { stopAll(); return; }
        if (playing) playRequestId = requestAnimationFrame(step);
      }
      // Start all clips on all tracks, honoring mute/solo
      let soloTracks = tracks.filter(t=>t.solo);
      let playTracks = soloTracks.length ? soloTracks : tracks.filter(t=>!t.muted);
      playTracks.forEach(track => {
        track.clips.forEach(clip => {
          if (clip.startTime+clip.duration < playheadTime) return;
          let source = audioCtx.createBufferSource();
          source.buffer = clip.audioBuffer;
          let offset = Math.max(0, playheadTime - clip.startTime) + clip.offset;
          let duration = Math.min(clip.duration - (offset - clip.offset), clip.audioBuffer.duration - offset);
          source.connect(audioCtx.destination);
          if (clip.startTime >= playheadTime) {
            source.start(audioCtx.currentTime + (clip.startTime - playheadTime), clip.offset, clip.duration);
          } else if (clip.startTime + clip.duration > playheadTime) {
            source.start(audioCtx.currentTime, offset, duration);
          }
          if (!window._playSources) window._playSources = [];
          window._playSources.push(source);
        });
      });
      // Animate playhead
      pauseBtn.disabled = false;
      playBtn.disabled = true;
      playRequestId = requestAnimationFrame(step);
      if (metronomeEnabled) startMetronome();
      setTimeout(stopAll, (MAX_TIME-playheadTime)*1000);
    }

    function stopAll() {
      if (window._playSources) {
        window._playSources.forEach(src => { try { src.stop(); } catch{} });
        window._playSources = [];
      }
      playing = false;
      if (playRequestId) cancelAnimationFrame(playRequestId);
      pauseBtn.disabled = true;
      playBtn.disabled = false;
      stopMetronome();
    }

    // --- File Upload ---
    fileInput.onchange = async (e) => {
      const files = e.target.files;
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      for (let file of files) {
        const arrayBuffer = await file.arrayBuffer();
        await new Promise((resolve) => {
          audioCtx.decodeAudioData(arrayBuffer, (buffer) => {
            addClipToFirstTrack(buffer, 0, buffer.duration, undefined, undefined, file.name.split(".")[0]);
            resolve();
          });
        });
      }
      fileInput.value = '';
    };

    // --- Add Track ---
    addTrackBtn.onclick = () => {
      tracks.push(createTrack());
      render();
    };

    // --- Timeline and Playhead ---
    timelineDiv.onclick = (e) => {
      playheadTime = e.offsetX / PIXELS_PER_SEC;
      renderTimeline();
    };
    function updatePlayhead(t) {
      playheadTime = t;
      renderTimeline();
    }

    // --- Clip Management ---
    function addClipToFirstTrack(buffer, startTime, duration, color, name) {
      if (tracks.length === 0) tracks.push(createTrack());
      tracks[0].clips.push(createClip(buffer, startTime, duration, 0, color, name));
      render();
    }
    function moveClip(fromTrackIdx, fromClipIdx, toTrackIdx, newStartTime) {
      let clip = tracks[fromTrackIdx].clips[fromClipIdx];
      tracks[fromTrackIdx].clips.splice(fromClipIdx, 1);
      clip.startTime = Math.max(0, Math.round(newStartTime*100)/100);
      tracks[toTrackIdx].clips.push(clip);
      deselectAllClips();
      clip.selected = true;
      render();
    }
    function selectClip(trackIdx, clipIdx) {
      deselectAllClips();
      let clip = tracks[trackIdx].clips[clipIdx];
      clip.selected = true;
      selectedClip = {trackIdx, clipIdx};
      render();
    }
    function deselectAllClips() {
      tracks.forEach(track => track.clips.forEach(c => c.selected = false));
      selectedClip = null;
    }

    // --- Context Menus ---
    function showClipContextMenu(e, tIdx, cIdx, clipDiv) {
      removeContextMenu();
      const menu = document.createElement('div');
      menu.className = 'context-menu';
      menu.style.left = e.clientX + 'px';
      menu.style.top = e.clientY + 'px';

      let actions = [
        {label: 'Split at cursor', fn: () => splitClip(tIdx, cIdx, ((e.offsetX-8)/clipDiv.offsetWidth)) },
        {label: 'Delete', fn: () => { tracks[tIdx].clips.splice(cIdx,1); render(); }},
        {label: 'Duplicate', fn: () => { duplicateClip(tIdx, cIdx); }},
        {label: 'Rename', fn: () => { renameClip(tIdx, cIdx); }},
        {label: 'Reverse', fn: () => { reverseClip(tIdx, cIdx); }},
        {label: 'Normalize', fn: () => { normalizeClip(tIdx, cIdx); }},
        {label: 'Export Clip', fn: () => { exportClip(tIdx, cIdx); }},
        {label: 'Move to New Track', fn: () => { moveClipToNewTrack(tIdx, cIdx); }},
        {sep:true},
        {label: 'Change Color', color:true, fn: (color) => { changeClipColor(tIdx, cIdx, color); }}
      ];
      actions.forEach(act => {
        if (act.sep) {
          let sep = document.createElement('div');
          sep.className = 'context-menu-sep';
          menu.appendChild(sep);
          return;
        }
        let item = document.createElement('div');
        item.className = 'context-menu-item';
        item.innerText = act.label;
        if (act.color) {
          let colorInput = document.createElement('input');
          colorInput.type = 'color';
          colorInput.value = tracks[tIdx].clips[cIdx].color;
          colorInput.className = 'color-picker';
          colorInput.oninput = (ev) => { act.fn(ev.target.value); removeContextMenu(); };
          item.appendChild(colorInput);
        } else {
          item.onclick = () => { act.fn(); removeContextMenu(); };
        }
        menu.appendChild(item);
      });
      document.body.appendChild(menu);
      contextMenuEl = menu;
      document.addEventListener('mousedown', removeContextMenu, {once: true});
    }
    function showTrackContextMenu(e, tIdx, trackDiv) {
      removeContextMenu();
      const menu = document.createElement('div');
      menu.className = 'context-menu';
      menu.style.left = e.clientX + 'px';
      menu.style.top = e.clientY + 'px';

      let actions = [
        {label: tracks[tIdx].muted ? "Unmute" : "Mute", fn: () => { tracks[tIdx].muted = !tracks[tIdx].muted; render(); }},
        {label: tracks[tIdx].solo ? "Unsolo" : "Solo", fn: () => { tracks[tIdx].solo = !tracks[tIdx].solo; render(); }},
        {label: 'Rename Track', fn: () => { renameTrack(tIdx); }},
        {label: 'Delete Track', fn: () => { tracks.splice(tIdx,1); render(); }},
        {label: 'Add New Clip (Silence)', fn: () => { addSilenceClip(tIdx); }},
        {sep:true},
        {label: 'Change Track Color', color:true, fn: (color) => { tracks[tIdx].color = color; render(); }},
      ];
      actions.forEach(act => {
        if (act.sep) {
          let sep = document.createElement('div');
          sep.className = 'context-menu-sep';
          menu.appendChild(sep);
          return;
        }
        let item = document.createElement('div');
        item.className = 'context-menu-item';
        item.innerText = act.label;
        if (act.color) {
          let colorInput = document.createElement('input');
          colorInput.type = 'color';
          colorInput.value = tracks[tIdx].color;
          colorInput.className = 'color-picker';
          colorInput.oninput = (ev) => { act.fn(ev.target.value); removeContextMenu(); };
          item.appendChild(colorInput);
        } else {
          item.onclick = () => { act.fn(); removeContextMenu(); };
        }
        menu.appendChild(item);
      });
      document.body.appendChild(menu);
      contextMenuEl = menu;
      document.addEventListener('mousedown', removeContextMenu, {once: true});
    }
    function removeContextMenu() {
      if (contextMenuEl) contextMenuEl.remove();
      contextMenuEl = null;
    }
    // --- Clip DAW Actions ---
    function splitClip(tIdx, cIdx, relPos) {
      let clip = tracks[tIdx].clips[cIdx];
      const splitSec = clip.duration * relPos;
      if (splitSec < 0.01 || splitSec > clip.duration - 0.01) return;
      let first = createClip(clip.audioBuffer, clip.startTime, splitSec, clip.offset, clip.color, clip.name);
      let second = createClip(clip.audioBuffer, clip.startTime + splitSec, clip.duration - splitSec, clip.offset + splitSec, clip.color, clip.name);
      tracks[tIdx].clips.splice(cIdx, 1, first, second);
      render();
    }
    function duplicateClip(tIdx, cIdx) {
      let orig = tracks[tIdx].clips[cIdx];
      let dup = createClip(orig.audioBuffer, orig.startTime + orig.duration + 0.15, orig.duration, orig.offset, orig.color, orig.name + " Copy");
      tracks[tIdx].clips.push(dup);
      render();
    }
    function renameClip(tIdx, cIdx) {
      let newName = prompt("Enter new name for clip:", tracks[tIdx].clips[cIdx].name);
      if (newName) { tracks[tIdx].clips[cIdx].name = newName; render(); }
    }
    function reverseClip(tIdx, cIdx) {
      let clip = tracks[tIdx].clips[cIdx];
      let ch = clip.audioBuffer.getChannelData(0);
      let reversed = new Float32Array(ch.length);
      for(let i=0; i<ch.length; i++) reversed[i] = ch[ch.length-1-i];
      let buffer = audioCtx.createBuffer(1, ch.length, clip.audioBuffer.sampleRate);
      buffer.copyToChannel(reversed, 0);
      clip.audioBuffer = buffer;
      render();
    }
    function normalizeClip(tIdx, cIdx) {
      let clip = tracks[tIdx].clips[cIdx];
      let ch = clip.audioBuffer.getChannelData(0);
      let peak = Math.max(...ch.map(Math.abs));
      if (peak < 0.01) return;
      for(let i=0; i<ch.length; i++) ch[i] /= peak;
      render();
    }
    function changeClipColor(tIdx, cIdx, color) {
      tracks[tIdx].clips[cIdx].color = color;
      render();
    }
    function exportClip(tIdx, cIdx) {
      let clip = tracks[tIdx].clips[cIdx];
      let wav = audioBufferToWav(clip.audioBuffer, clip.offset, clip.duration);
      let blob = new Blob([wav], {type: 'audio/wav'});
      let url = URL.createObjectURL(blob);
      let a = document.createElement('a');
      a.href = url;
      a.download = (clip.name||"Clip") + ".wav";
      a.click();
      setTimeout(()=>URL.revokeObjectURL(url), 1000);
    }
    function moveClipToNewTrack(tIdx, cIdx) {
      let clip = tracks[tIdx].clips.splice(cIdx, 1)[0];
      let tr = createTrack();
      tr.clips.push(clip);
      tracks.push(tr);
      render();
    }
    // --- Track DAW Actions ---
    function renameTrack(tIdx) {
      let newName = prompt("Enter new track name:", tracks[tIdx].label);
      if (newName) { tracks[tIdx].label = newName; render(); }
    }
    function addSilenceClip(tIdx) {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      let dur = 2;
      let buffer = audioCtx.createBuffer(1, Math.floor(audioCtx.sampleRate*dur), audioCtx.sampleRate);
      tracks[tIdx].clips.push(createClip(buffer, 0, dur, 0, undefined, "Silence"));
      render();
    }

    // --- Export Utility ---
    function audioBufferToWav(buffer, offset, duration) {
      var numOfChan = buffer.numberOfChannels,
        length = Math.floor(duration ? duration*buffer.sampleRate : buffer.length),
        sampleRate = buffer.sampleRate,
        outBuffer = new ArrayBuffer(44 + length * 2 * numOfChan),
        view = new DataView(outBuffer),
        channels = [],
        i, sample, pos = 0;

      // write WAVE header
      setUint32(0x46464952); // "RIFF"
      setUint32(outBuffer.byteLength - 8);
      setUint32(0x45564157); // "WAVE"
      setUint32(0x20746d66); // "fmt " chunk
      setUint32(16);
      setUint16(1);
      setUint16(numOfChan);
      setUint32(sampleRate);
      setUint32(sampleRate * 2 * numOfChan);
      setUint16(numOfChan * 2);
      setUint16(16);
      setUint32(0x61746164); // "data" - chunk
      setUint32(length * 2 * numOfChan);

      // write interleaved data
      for(i=0; i<numOfChan; i++)
        channels.push(buffer.getChannelData(i).subarray(
          Math.floor(offset ? offset*sampleRate : 0),
          Math.floor((offset ? offset*sampleRate : 0) + length)));
      pos = 44;
      for(i=0; i<length; i++)
        for(var ch=0; ch<numOfChan; ch++) {
          sample = Math.max(-1, Math.min(1, channels[ch][i]));
          view.setInt16(pos, sample<0 ? sample*0x8000 : sample*0x7FFF, true);
          pos += 2;
        }

      function setUint16(data) { view.setUint16(pos, data, true); pos += 2; }
      function setUint32(data) { view.setUint32(pos, data, true); pos += 4; }
      return outBuffer;
    }

    // --- Keyboard Shortcuts ---
    document.addEventListener('keydown', (e) => {
      if (document.activeElement && (
        document.activeElement.tagName === "INPUT" ||
        document.activeElement.tagName === "SELECT"
      )) return;
      if (e.key === 'r' || e.key === 'R') recordBtn.click();
      if (e.key === 's' || e.key === 'S') stopBtn.click();
      if (e.key === ' ' && !isRecording) { e.preventDefault(); playBtn.click(); }
      if (e.key === '+' || e.key === '=') zoomInBtn.click();
      if (e.key === '-' || e.key === '_') zoomOutBtn.click();
      if (!selectedClip) return;
      let {trackIdx, clipIdx} = selectedClip;
      if (e.key === 'Delete' || e.key === 'Backspace') {
        tracks[trackIdx].clips.splice(clipIdx, 1);
        selectedClip = null;
        render();
      } else if (e.key === 'c' && (e.ctrlKey || e.metaKey)) {
        copiedClip = JSON.parse(JSON.stringify(tracks[trackIdx].clips[clipIdx]));
      } else if (e.key === 'v' && (e.ctrlKey || e.metaKey)) {
        if (copiedClip) tracks[trackIdx].clips.push({...copiedClip, id: Math.random().toString(36).slice(2,9)});
        render();
      }
    });

    // --- Metronome ---
    metronomeBtn.onclick = () => {
      metronomeEnabled = !metronomeEnabled;
      if (metronomeEnabled) {
        metronomeBtn.classList.add('metronome-on');
        metronomeBtn.innerText = "Metronome On";
        if ((isRecording || playing)) startMetronome();
      } else {
        metronomeBtn.classList.remove('metronome-on');
        metronomeBtn.innerText = "Metronome Off";
        stopMetronome();
      }
    };
    function startMetronome() {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      if (!metronomeTickBuffer) createMetronomeBuffers();
      let beatCount = 0;
      let nextTick = audioCtx.currentTime + 0.1;
      function schedule() {
        while (nextTick < audioCtx.currentTime + 0.4) {
          let source = audioCtx.createBufferSource();
          if (beatCount % timeSigNum === 0) {
            source.buffer = metronomeAccentBuffer;
          } else {
            source.buffer = metronomeTickBuffer;
          }
          source.connect(audioCtx.destination);
          source.start(nextTick);
          beatCount++;
          nextTick += getSecPerBeat();
        }
        if (playing || isRecording) metronomeTimeout = setTimeout(schedule, 100);
      }
      schedule();
    }
    function stopMetronome() { clearTimeout(metronomeTimeout); }
    function createMetronomeBuffers() {
      const sr = audioCtx.sampleRate;
      let tick = audioCtx.createBuffer(1, sr*0.07, sr);
      let tdata = tick.getChannelData(0);
      for (let i = 0; i < tdata.length; i++) tdata[i] = Math.sin(2*Math.PI*1800*i/sr) * Math.exp(-i/(sr*0.03));
      metronomeTickBuffer = tick;
      let tickA = audioCtx.createBuffer(1, sr*0.1, sr);
      let tdataA = tickA.getChannelData(0);
      for (let i = 0; i < tdataA.length; i++) tdataA[i] = Math.sin(2*Math.PI*1100*i/sr) * Math.exp(-i/(sr*0.04));
      metronomeAccentBuffer = tickA;
    }

    // --- Controls for BPM & Time Signature ---
    bpmInput.onchange = () => {
      let newBPM = parseInt(bpmInput.value);
      if (isNaN(newBPM) || newBPM < 20 || newBPM > 300) bpmInput.value = bpm;
      else bpm = newBPM;
      render();
    }
    tsNumInput.onchange = () => { timeSigNum = parseInt(tsNumInput.value); render(); }
    tsDenInput.onchange = () => { timeSigDen = parseInt(tsDenInput.value); render(); }

    // --- Zoom ---
    function setZoom(newZoom) {
      zoomLevel = Math.max(0.2, Math.min(2.8, newZoom));
      PIXELS_PER_SEC = BASE_PIXELS_PER_SEC * zoomLevel;
      render();
    }
    zoomInBtn.onclick = () => setZoom(zoomLevel*1.25);
    zoomOutBtn.onclick = () => setZoom(zoomLevel/1.25);
    // Mousewheel zoom on timeline
    timelineDiv.addEventListener('wheel', e => {
      e.preventDefault();
      setZoom(zoomLevel * (e.deltaY < 0 ? 1.13 : 0.89));
    });
    // Horizontal scroll with shift+wheel
    workspace.addEventListener('wheel', e => {
      if (e.shiftKey) {
        workspace.scrollLeft += e.deltaY;
      }
    });

    // --- Init ---
    function init() {
      bpm = DEFAULT_BPM;
      timeSigNum = DEFAULT_SIG_NUM;
      timeSigDen = DEFAULT_SIG_DEN;
      tracks = [];
      for (let i = 0; i < DEFAULT_TRACKS; i++) {
        tracks.push(createTrack());
      }
      render();
    }
    window.onload = init;

    // Hide context menu on resize/scroll/click
    window.addEventListener('resize', removeContextMenu);
    window.addEventListener('scroll', removeContextMenu);
    document.body.addEventListener('mousedown', (e) => {
      if (contextMenuEl && !contextMenuEl.contains(e.target)) removeContextMenu();
      if (!e.target.className.includes('clip')) deselectAllClips(), render();
    });
  </script>
</body>
</html>